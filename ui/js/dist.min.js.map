{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///src/playback.ts","webpack:///src/scheduling.ts","webpack:///src/entrypoint.ts","webpack:///src/index.ts","webpack:///../common/temp/node_modules/.registry.npmjs.org/soundbank-pitch-shift/1.0.3/node_modules/soundbank-pitch-shift/index.js","webpack:///../common/temp/node_modules/.registry.npmjs.org/custom-audio-node/0.3.1/node_modules/custom-audio-node/index.js","webpack:///../common/temp/node_modules/.registry.npmjs.org/custom-audio-node/0.3.1/node_modules/custom-audio-node/audio-param.js","webpack:///../gapless-meta/index.js","webpack:///src/state.ts","webpack:///src/tresholds.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","getPlayState","state","data","playState","audio","paused","scheduled","effectiveStartTimeMillis","startTime","stopTime","duration","positionMillis","currentTime","context","playbackRate","playCurrentTrackFrom","dontPrepareUpcomingTracks","stopAllTracksWithoutEnding","tracks","track","currentTrack","playTrack","prepareUpcomingTracks","scheduleTimeUpdated","trackData","source","createBufferSource","adjustPitchWithPlaybackRate","pitchShift","PitchShift","connect","gainNode","transpose","Math","log2","buffer","gaps","paddingStartSeconds","paddingEndSeconds","meta","vbrInfo","numberOfFrames","lameInfo","samples","samplesPerFrame","realSamples","paddingStart","paddingEnd","sampleRate","length","console","log","start","suppressEndedEvent","addEventListener","sendEvent","slice","createTrackEndedListenerFull","effectiveStartTimeSeconds","now","play","undefined","max","timeoutMillis","timeout","setTimeout","onended","createTrackEndedListenerBasic","playTrackWhenLoaded","playOnLoad","promise","callback","Promise","resolve","stop","clearTimeout","pause","animationFrameRequest","cancelAnimationFrame","requestAnimationFrame","timeUpdated","count","Error","ended","beginPlayback","min","self","changesMade","trackExpectedPlayingState","previousTrackExpectedPlayingState","timeouts","download","decode","playingUntil","timeRemaining","withinDownloadThreshold","thresholds","downloadThresholdSeconds","withinDecodeThreshold","decodeThresholdSeconds","diff","millis","downloadScheduledAt","performance","decodeScheduledAt","bytes","decodeAudioData","then","catch","error","dispatchError","playback","playState2","reject","Audio","src","URL","createObjectURL","threshold","basicModeThresholdSeconds","createMediaElementSource","revokeObjectURL","e","playbackMode","fetch","blob","file","reader","FileReader","onload","ev","target","result","onerror","abort","readAsArrayBuffer","window","PreciseAudio","PreciseAudioEvent","Event","eventType","super","this","_target","EventTarget","State","event","dispatchEvent","ErrorEvent","input","output","destination","firstTrack","remaining","defaultPlaybackRate","push","updateUpcomingTracks","followingSongs","removed","splice","map","scheduling","decodingAt","downloadingAt","gain","volume","muted","v","updateGain","updateTracks","suppressEvent","resume","skip","currentTimeMillis","positionSeconds","adjust","changeConfiguration","sinkId","listener","removeEventListener","createAudioNode","getMultiplier","x","createDelayTimeBuffer","activeTime","fadeTime","shiftUp","length1","createBuffer","getChannelData","audioContext","instance","Jungle","createGain","wet","dry","node","defaultValue","setPitchOffset","set","delayTime","bufferTime","mod1","mod2","mod3","mod4","shiftDownBuffer","shiftUpBuffer","loop","mod1Gain","mod2Gain","mod3Gain","mod4Gain","modGain1","modGain2","delay1","createDelay","delay2","fade1","fade2","fadeBuffer","fadeLength","fadeIndex1","fadeIndex2","sqrt","createFadeBuffer","mix1","mix2","t2","setDelay","setTargetAtTime","mult","abs","createAudioParam","channel","_targetCount","_output","_onDestinationChange","disconnect","param","params","onDestinationChange","keys","addAudioParams","fence","setValueAtTime","targets","_targets","_lastValue","timeConstant","linearRampToValueAtTime","endTime","exponentialRampToValueAtTime","setValueCurveAtTime","curve","cancelScheduledValues","clearTargets","addTarget","options","AudioParam","writable","MPEGAudioVersionMapping","0","2","3","MPEGLayerMapping","1","MODES","SAMPLE_RATES","BITRATES_RAW","BITRATES","SAMPLES_PER_FRAME","LAYER_3_SIDE_INFORMATION_BYTES","extractAsciiString","index","str","char","String","fromCharCode","extractTagSize","offset","hasFooter","getMetadata","Uint8Array","tagSize","frameHeader","frameSync","audioVersion","layerIndex","bitrateIndex","sampleRateIndex","version","layer","metadata","bitrate","dataStart","sideMode","vbrStart","vbrHeaderID","hasFrames","hasBytes","hasTOC","hasQuality","framesStart","isCBR","lameExtensionStart","encoder","parseAudioFrameHeader","default","Thresholds","AudioContext","_basicModeThresholdSeconds","_downloadThresholdSeconds","_decodeThresholdSeconds"],"mappings":"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","file":"dist.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","import PitchShift = require('soundbank-pitch-shift');\n\nimport { Track, PlayStatePlaying, TrackDataReady, PlayStateBasic, TrackDataModeBasic } from './data';\nimport { prepareUpcomingTracks } from './scheduling';\nimport { State } from './state';\n\nexport function getPlayState(state: State, data: TrackDataReady): PlayStateBasic & { mode: 'full' | 'basic' } {\n  if (data.mode === 'full') {\n    return {\n      mode: 'full',\n      ...data.playState\n    };\n  } else {\n    if (data.audio.paused) {\n      if (data.scheduled) {\n        return {\n          mode: 'basic',\n          state: 'playing',\n          effectiveStartTimeMillis: data.scheduled.startTime * 1000,\n          stopTime: data.scheduled.startTime + data.audio.duration\n        };\n      } else {\n        return {\n          mode: 'basic',\n          state: 'paused',\n          positionMillis: data.audio.currentTime * 1000\n        };\n      }\n    } else {\n      const effectiveStartTimeMillis =\n        (state.context.currentTime -\n          data.audio.currentTime / data.audio.playbackRate)\n        * 1000;\n      return {\n        mode: 'basic',\n        state: 'playing',\n        effectiveStartTimeMillis,\n        stopTime: effectiveStartTimeMillis / 1000 + data.audio.duration\n      };\n    }\n  }\n}\n\n/**\n * Play the current song from the given timestamp.\n * And cancel the scheduling of any upcoming songs.\n *\n * @param dontPrepareUpcomingTracks Set to `true` when being called from\n * `this.prepareUpcomingTracks()`, to avoid calling the callee uneccesarily.\n */\nexport function playCurrentTrackFrom(\n    state: State, positionMillis: number, dontPrepareUpcomingTracks ?: true) {\n  // Stop / Deschedule all currently playing tracks\n  stopAllTracksWithoutEnding(state.tracks);\n  // Play with a little delay\n  const track = state.currentTrack();\n  if (track && track.data?.state === 'ready') {\n    const startTime = state.context.currentTime + 0.05;\n    playTrack(state, startTime, track.data, positionMillis);\n  }\n  if (!dontPrepareUpcomingTracks) {\n    prepareUpcomingTracks(state);\n  }\n  scheduleTimeUpdated(state);\n}\n\n/**\n * Schedule the given track to play at a specific time\n * in the time coordinate system of the audio context (`this.context`).\n *\n * @param startTime the time, in seconds, relative to the time coordinate\n *                  system of the audio context,\n *                  that the audio should begin to play.\n * @param trackData the `data` property of the track that needs to be played.\n * @param positionMillis the position within the track that playback should\n *                       begin from, in milliseconds.\n *                       `0` is the start of the track.\n */\nexport function playTrack(state: State, startTime: number, trackData: TrackDataReady, positionMillis: number) {\n  if (trackData.mode === 'full') {\n    const source = state.context.createBufferSource();\n    source.playbackRate.value = state.playbackRate;\n    if (state.playbackRate !== 1 && state.adjustPitchWithPlaybackRate) {\n      const pitchShift = PitchShift(state.context);\n      pitchShift.connect(state.gainNode);\n      // Calculate the notes (in 100 cents) to shift the pitch by\n      // based on the frequency ration\n      pitchShift.transpose = 12 * Math.log2(1 / state.playbackRate);\n      source.connect(pitchShift);\n    } else {\n      source.connect(state.gainNode);\n    }\n    source.buffer = trackData.buffer;\n    const gaps = {\n      paddingStartSeconds: 0,\n      paddingEndSeconds: 0\n    };\n    // Get gapless information if available\n    if (trackData.meta?.vbrInfo?.numberOfFrames && trackData.meta.lameInfo) {\n      const samples = trackData.meta.samplesPerFrame *\n        trackData.meta.vbrInfo.numberOfFrames;\n      const realSamples =\n        samples -\n        trackData.meta.lameInfo.paddingStart -\n        trackData.meta.lameInfo.paddingEnd;\n      const paddingStartSeconds =\n        1 / trackData.meta.sampleRate * trackData.meta.lameInfo.paddingStart;\n      const paddingEndSeconds =\n        1 / trackData.meta.sampleRate * trackData.meta.lameInfo.paddingEnd;\n      if (trackData.buffer.length === realSamples) {\n        console.log('Loaded track already gapless');\n      } else if (trackData.buffer.length === samples) {\n        gaps.paddingStartSeconds = paddingStartSeconds;\n        gaps.paddingEndSeconds = paddingEndSeconds;\n        console.log('Adjusting for gapless playback');\n      } else if (trackData.buffer.length === samples + 1152) {\n        // For some reason, firefox seems to add an additional 1152 samples of\n        // padding to the encoded track.\n        gaps.paddingStartSeconds =\n          paddingStartSeconds + 1 / trackData.meta.sampleRate * 576;\n        gaps.paddingEndSeconds =\n          paddingEndSeconds + 1 / trackData.meta.sampleRate * 576;\n        console.log('Adjusting for gapless playback, with additional 1152 samples');\n      } else {\n        console.log(\n          'Mismatch between gapless metadata and loaded audio, full:',\n          samples,\n          'real:',\n          realSamples,\n          'decoded:',\n          trackData.buffer.length\n        );\n      }\n    } else {\n      console.log('Unable to get gapless metadata from track', trackData.meta);\n    }\n    const stopTime =\n      startTime +\n      (trackData.buffer.duration -\n      gaps.paddingStartSeconds -\n      gaps.paddingEndSeconds -\n      positionMillis / 1000) / state.playbackRate;\n    source.start(startTime, positionMillis / 1000 + gaps.paddingStartSeconds);\n    trackData.playState = {\n      state: 'playing',\n      suppressEndedEvent: false,\n      source,\n      effectiveStartTimeMillis:\n        startTime * 1000 - positionMillis / state.playbackRate,\n      stopTime\n    };\n    source.addEventListener('ended',\n      createTrackEndedListenerFull(state, trackData.playState));\n  } else {\n    // TODO: begin playback for basic audio\n    const effectiveStartTimeSeconds = startTime - positionMillis / 1000;\n    const now = state.context.currentTime;\n    const play = () => {\n      trackData.scheduled = undefined;\n      const now = state.context.currentTime;\n      trackData.suppressEndedEvent = undefined;\n      trackData.audio.playbackRate = state.playbackRate;\n      trackData.audio.currentTime = Math.max(0, now - effectiveStartTimeSeconds),\n      trackData.audio.play();\n    };\n    if (effectiveStartTimeSeconds <= now) {\n      play();\n    } else {\n      const timeoutMillis = (effectiveStartTimeSeconds - now) * 1000;\n      trackData.scheduled = {\n        timeout: setTimeout(play, timeoutMillis),\n        startTime: effectiveStartTimeSeconds\n      };\n    }\n    /*\n     * Setup listeners (user properties rather than addEventListener as we\n     * don't want multiple listeners per event)\n     */\n    trackData.audio.onended = createTrackEndedListenerBasic(state, trackData);\n  }\n}\n\n\n/**\n * Create a listener that should get called when the currently playing track\n * has ended (used only for tracks in \"full\" mode)\n *\n * @param track - the track that should be playing\n */\nfunction createTrackEndedListenerFull(state: State, playState: PlayStatePlaying) {\n  return () => {\n    const track = state.currentTrack();\n    // Check if current track is loaded and expected track\n    if (track?.data?.state !== 'ready' ||\n        track.data.mode !== 'full' ||\n        track.data.playState !== playState)\n      return;\n    if (playState.state === 'playing' && !playState.suppressEndedEvent) {\n      if (state.tracks.length === 1) {\n        // If there are no following tracks,\n        // keep the last track, and move the cursor to the beginning\n        track.data.playState = {\n          state: 'paused',\n          positionMillis: 0\n        };\n        state.sendEvent('ended');\n      } else {\n        state.tracks = state.tracks.slice(1);\n        state.sendEvent('next');\n      }\n    }\n  };\n}\n\nfunction createTrackEndedListenerBasic(state: State, data: TrackDataModeBasic) {\n  return () => {\n    const track = state.currentTrack();\n    // Check if current track is loaded and expected track\n    if (track?.data?.state !== 'ready' || track.data !== data)\n      return;\n    if (!data.suppressEndedEvent) {\n      if (state.tracks.length === 1) {\n        // If there are no following tracks,\n        // keep the last track, and moe the cursor to the beginning\n        track.data.audio.currentTime = 0;\n        state.sendEvent('ended');\n      } else {\n        state.tracks = state.tracks.slice(1);\n        playCurrentTrackFrom(state, 0);\n        state.sendEvent('next');\n      }\n    }\n  };\n}\n\n/**\n * Skip a certain number of tracks ahead.\n */\nexport function skip(state: State, count: number) {\n  if (count < 1)\n    throw new Error('Invalid number of tracks to skip: ' + count);\n  const track = state.currentTrack();\n  let ended = false;\n  if (track) {\n    /** Begin playback of next track automatically? */\n    const beginPlayback = !!(\n      track.data?.state === 'ready' && getPlayState(state, track.data).state === 'playing'\n      || track.data?.state !== 'ready' && track?.playOnLoad);\n    stopAllTracksWithoutEnding(state.tracks);\n    count = Math.min(count, state.tracks.length);\n    state.tracks = state.tracks.slice(count);\n    if (state.tracks.length > 0) {\n      if (beginPlayback) {\n        const track = state.tracks[0];\n        if (track.data?.state === 'ready') {\n          playCurrentTrackFrom(state, 0);\n        } else {\n          playTrackWhenLoaded(track);\n        }\n      }\n      prepareUpcomingTracks(state);\n    } else {\n      ended = true;\n    }\n  }\n  // Send Events\n  for (let i = 0; i < count ; i++)\n    state.sendEvent('next');\n  if (ended)\n    state.sendEvent('ended');\n}\n\nexport function playTrackWhenLoaded(track: Track) {\n  if (track.playOnLoad) {\n    return track.playOnLoad.promise;\n  } else {\n    let callback: (() => void) | null = null;\n    const promise = new Promise<void>(resolve => {\n      callback = resolve;\n    });\n    if (callback) {\n      track.playOnLoad = {\n        callback, promise\n      };\n    }\n    return promise;\n  }\n}\n\n/**\n * Stop all the tracks in the given array\n * (including tracks that have been scheduled to play in the future,\n * but have not yet started),\n * while ignoring the 'ended' event that will\n * be dispatched by the `AudioBufferSourceNode`.\n *\n * @param positionMillis the value to set for the positionMillis of the first\n *                       track in the array once paused.\n */\nexport function stopAllTracksWithoutEnding(tracks: Track[], positionMillis = 0) {\n  for (let i = 0; i < tracks.length; i++) {\n    const track = tracks[i];\n    console.log(track.data?.state);\n    if (track.data?.state === 'ready') {\n      console.log('ready!!!');\n      if (track.data.mode === 'full' &&\n          track.data.playState.state === 'playing') {\n        track.data.playState.suppressEndedEvent = true;\n        track.data.playState.source.stop();\n        track.data.playState = {\n          state: 'paused',\n          positionMillis: i === 0 ? positionMillis : 0\n        };\n      } else if (track.data.mode === 'basic') {\n        if (!track.data.audio.paused) {\n          track.data.suppressEndedEvent = true;\n          track.data.audio.pause();\n          track.data.audio.currentTime = i === 0 ? (positionMillis / 1000) : 0;\n        } else if (track.data.scheduled) {\n          clearTimeout(track.data.scheduled.timeout);\n          track.data.scheduled = undefined;\n        }\n      }\n    }\n  }\n}\n\n/**\n * Used with requestAnimationFrame to dispatch timeupdate events\n */\nfunction timeUpdated(state: State) {\n  state.sendEvent('timeupdate');\n  const track = state.currentTrack();\n  if (track?.data?.state === 'ready' &&\n      getPlayState(state, track.data).state === 'playing') {\n    scheduleTimeUpdated(state);\n  }\n}\n\nfunction scheduleTimeUpdated(state: State) {\n  if (state.animationFrameRequest !== null)\n    cancelAnimationFrame(state.animationFrameRequest);\n  state.animationFrameRequest = requestAnimationFrame(() => timeUpdated(state));\n}\n","import getMetadata from '@synesthesia-project/gapless-meta';\n\nimport { State } from './state';\nimport * as playback from './playback';\n\ntype ExpectedPlayingState = {\n  stopTime: number;\n  mode: 'full' | 'basic';\n} | null;\n\n/**\n * Download, decode or schedule the playback for any\n * upcoming tracks that require it.\n */\nexport function prepareUpcomingTracks(state: State) {\n  const self = () => prepareUpcomingTracks(state);\n  let changesMade = false;\n  const now = state.context.currentTime;\n  let trackExpectedPlayingState: ExpectedPlayingState = null;\n  for (let i = 0; i < state.tracks.length; i++) {\n    // Type annotation fix for: https://github.com/microsoft/TypeScript/issues/33191\n    const previousTrackExpectedPlayingState: ExpectedPlayingState =\n      trackExpectedPlayingState;\n    trackExpectedPlayingState = null;\n    const track = state.tracks[i];\n\n    // Clear any previous timeouts for this track\n    if (track.timeouts?.download) {\n      clearTimeout(track.timeouts.download);\n      changesMade = true;\n    }\n    if (track.timeouts?.decode) {\n      clearTimeout(track.timeouts?.decode);\n      changesMade = true;\n    }\n    track.timeouts = {};\n\n    /**\n     * How long is the previous track playing until,\n     * if we don't yet know, this will be undefined.\n     *\n     * Type annotations are fix for:\n     * https://github.com/microsoft/TypeScript/issues/33191\n     */\n    const playingUntil: number | undefined = i === 0 ? now :\n      (previousTrackExpectedPlayingState as any)?.stopTime;\n\n    // If we don't know when the previous song will be playing until,\n    // there's nothing more we can do for this track.\n    if (playingUntil === undefined) continue;\n\n    const timeRemaining = playingUntil - now;\n    const withinDownloadThreshold = i === 0 ||\n      timeRemaining < state.thresholds.downloadThresholdSeconds;\n    const withinDecodeThreshold = i === 0 ||\n      timeRemaining < state.thresholds.decodeThresholdSeconds;\n\n    // Schedule timers for preparing next tracks at thresholds\n    // (with a few extra milliseconds)\n    // (if playing)\n    if (!state.paused()) {\n      if (!withinDownloadThreshold) {\n        const diff = timeRemaining - state.thresholds.downloadThresholdSeconds;\n        const millis = Math.max(0, diff * 1000) + 10;\n        track.timeouts.downloadScheduledAt = performance.now() + millis;\n        track.timeouts.download =\n          setTimeout(self, millis);\n        changesMade = true;\n      }\n      if (!withinDecodeThreshold) {\n        const diff = timeRemaining - state.thresholds.decodeThresholdSeconds;\n        const millis = Math.max(0, diff * 1000) + 10;\n        track.timeouts.decodeScheduledAt = performance.now() + millis;\n        track.timeouts.decode =\n          setTimeout(self, millis);\n        changesMade = true;\n      }\n    }\n\n    if (!track.data) {\n\n      // Track is not downloaded, do we need to download it?\n\n      if (withinDownloadThreshold) {\n        track.data = {\n          state: 'preparing-download'\n        };\n        changesMade = true;\n        // Firstly, use an HTMLAudioElement to get the approximate duration\n        // of the track\n        type PlaybackMode = {\n          mode: 'basic';\n          audio: HTMLAudioElement;\n        } | {\n          mode: 'full';\n          duration: number;\n        };\n        const durationPromise = new Promise<PlaybackMode>((resolve, reject) => {\n          const audio = new Audio();\n          const src = typeof track.source === 'string' ?\n            track.source : URL.createObjectURL(track.source);\n          audio.src = src;\n          audio.addEventListener('loadedmetadata', () => {\n            const duration = audio.duration;\n            const threshold = state.thresholds.basicModeThresholdSeconds;\n            const useBasic =\n              threshold === 'always' ||\n              threshold !== 'never' && threshold < duration;\n            if (useBasic) {\n              const node = state.context.createMediaElementSource(audio);\n              node.connect(state.gainNode);\n              resolve({ mode: 'basic', audio });\n            } else {\n              audio.src = '';\n              if (typeof track.source !== 'string')\n                URL.revokeObjectURL(src);\n              resolve({ mode: 'full', duration });\n            }\n          });\n          audio.addEventListener('error', e => {\n            if (typeof track.source !== 'string')\n              URL.revokeObjectURL(src);\n            reject(e.error);\n          });\n        });\n        durationPromise.then(playbackMode => {\n          if (playbackMode.mode === 'basic') {\n            track.data = {\n              state: 'ready',\n              mode: 'basic',\n              audio: playbackMode.audio\n            };\n            state.sendEvent('trackstateupdate');\n            self();\n          } else {\n            const { duration } = playbackMode;\n            let download: Promise<Blob | File>;\n            // Fetch the file if neccesary\n            if (typeof track.source === 'string') {\n              download = fetch(track.source).then(r => r.blob());\n            } else {\n              download = Promise.resolve(track.source);\n            }\n            track.data = {\n              state: 'downloading',\n              duration\n            };\n            state.sendEvent('trackstateupdate');\n            return download.then(file =>\n              new Promise<ArrayBuffer>((resolve, reject) => {\n                const reader = new FileReader();\n                reader.onload = ev => {\n                  resolve(ev.target?.result as ArrayBuffer);\n                };\n                reader.onerror = () => {\n                  reader.abort();\n                  reject(reader.error);\n                };\n                reader.readAsArrayBuffer(file);\n              }).then(bytes => {\n                track.data = {\n                  state: 'downloaded',\n                  duration,\n                  bytes,\n                  meta: getMetadata(bytes)\n                };\n                state.sendEvent('trackstateupdate');\n                self();\n              })\n            );\n          }\n        }).catch(error => {\n          track.data = {\n            state: 'error',\n            error\n          };\n          state.dispatchError(error);\n          state.sendEvent('trackstateupdate');\n        });\n      }\n    } else if (track.data.state === 'downloading') {\n\n      // Set the current expected time to play until\n      trackExpectedPlayingState = {\n        mode: 'full',\n        stopTime: playingUntil + track.data.duration\n      };\n\n    } else if (track.data.state === 'downloaded') {\n\n      // Set the current expected time to play until\n      trackExpectedPlayingState = {\n        mode: 'full',\n        stopTime: playingUntil + track.data.duration\n      };\n\n      // Track is not decoded, do we need to decode it?\n\n      if (withinDecodeThreshold) {\n        const bytes = track.data.bytes;\n        const meta = track.data.meta;\n        track.data = {\n          state: 'decoding',\n          duration: track.data.duration,\n          meta\n        };\n        changesMade = true;\n        state.context.decodeAudioData(bytes).then(buffer => {\n          track.data = {\n            state: 'ready',\n            mode: 'full',\n            buffer,\n            meta,\n            playState: {\n              state: 'paused', positionMillis: 0\n            }\n          };\n          state.sendEvent('trackstateupdate');\n          if (state.tracks[0] === track) {\n            // If this is the current track,\n            // Trigger relevant events\n            state.sendEvent('loadeddata');\n            state.sendEvent('canplay');\n            state.sendEvent('canplaythrough');\n            state.sendEvent('timeupdate');\n          }\n          self();\n        }).catch(error => {\n          track.data = {\n            state: 'error',\n            error\n          };\n          state.dispatchError(error);\n          state.sendEvent('trackstateupdate');\n        });\n      }\n    } else if (track.data.state === 'ready') {\n\n      /** Play state *before* possibly playing */\n      const playState1 = playback.getPlayState(state, track.data);\n      if (playState1.state === 'paused') {\n        // Track is ready and paused, do we need to schedule it to play?\n\n        if (i === 0 && track.playOnLoad) {\n          playback.playCurrentTrackFrom(state, 0, true);\n          state.sendEvent('play');\n          track.playOnLoad.callback();\n          track.playOnLoad = undefined;\n        }\n\n        if (i > 0 &&\n            previousTrackExpectedPlayingState &&\n            previousTrackExpectedPlayingState.mode === 'full') {\n          // previous track is playing, let's enqueue next track\n          // (but only if it's in full mode)\n          playback.playTrack(\n            state,\n            previousTrackExpectedPlayingState.stopTime,\n            track.data,\n            0\n          );\n        }\n      }\n\n      // If the track is currently playing, or has been changed to playing\n      // update previousTrackPlayingState\n      /** Play state *after* possibly begining playback */\n      const playState2 = playback.getPlayState(state, track.data);\n      if (playState2.state === 'playing') {\n        trackExpectedPlayingState = playState2;\n      }\n    }\n  }\n\n  if (changesMade)\n    state.sendEvent('trackstateupdate');\n}\n","import PreciseAudio from '.';\n\n(window as any).PreciseAudio = PreciseAudio;\n","import { TrackState } from './data';\nimport { ErrorListener, EventTypes, Listener} from './events';\nimport * as playback from './playback';\nimport * as scheduling from './scheduling';\nimport { State } from './state';\n\n/* tslint:disable:unified-signatures */\n\nexport { TrackState };\n\n/**\n * An event triggered by a\n * {@link @synesthesia-project/precise-audio.PreciseAudio} object.\n */\nexport class PreciseAudioEvent extends Event {\n\n  private readonly _target: PreciseAudio;\n\n  public constructor(eventType: EventTypes, target: PreciseAudio) {\n    super(eventType);\n    this._target = target;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  public get target() {\n    return this._target;\n  }\n\n  /**\n   * @inheritdoc\n   */\n  public get currentTarget() {\n    return this._target;\n  }\n}\n\nexport interface AudioNodes {\n  /**\n   * The [`AudioContext`](https://developer.mozilla.org/en-US/docs/Web/API/AudioContext)\n   * in use by the respective instance of `PreciseAudio`.\n   */\n  context: AudioContext;\n  /**\n   * A node representing the audio that is being played,\n   * after volume adjustment.\n   * By default, this node is connected directly to `output`.\n   */\n  input: AudioNode;\n  /**\n   * The node that the library is outputting audio to.\n   */\n  output: AudioNode;\n}\n\n/**\n * An audio player that can seek and provide timestamps with millisecond\n * accuracy.\n *\n * In contrast to the `<audio>` tag, this class will load an entire track\n * into memory as a raw waveform, as otherwise, with most codecs,\n * it's impossible to seek to accurate locations in songs.\n *\n * **ExampleUsage:**\n *\n * ```ts\n * import PreciseAudio from '@synesthesia-project/precise-audio';\n *\n * const audio = new PreciseAudio();\n * audio.loadAudioFile(...);\n * ```\n *\n * Motivation, more usage instructions, and other details can be found\n * [in the project GitHub repository](https://github.com/synesthesia-project/synesthesia/tree/master/precise-audio)\n */\nexport default class PreciseAudio extends EventTarget {\n\n  private readonly state = new State(\n    (eventType: EventTypes) => {\n      const event = new PreciseAudioEvent(eventType, this);\n      this.dispatchEvent(event);\n    },\n    (error: Error) => {\n      const event = new ErrorEvent('error', {\n        error\n      });\n      this.dispatchEvent(event);\n    });\n\n  /**\n   * Retreive the\n   * [`AudioContext`](https://developer.mozilla.org/en-US/docs/Web/API/AudioContext)\n   * and some of the internal audio nodes that are being used by the class,\n   * to allow for modification of the audio-processing graph,\n   * for example to add an equalizer or attach an analyser for visualizations.\n   *\n   * By default, the `input` returned is directly connected to `output`.\n   */\n  public getAudioNodes(): AudioNodes {\n    return {\n      context: this.state.context,\n      input: this.state.gainNode,\n      output: this.state.context.destination\n    };\n  }\n\n  /**\n   * Change the currently playing track,\n   * and the list of tracks that will play afterward.\n   */\n  public updateTracks(...tracks: Array<File | Blob | string>) {\n    const [firstTrack, ...remaining] = tracks;\n    const currentTrack = this.state.currentTrack();\n    if (!firstTrack || currentTrack?.source !== firstTrack) {\n      // Currently playing track needs updating\n      playback.stopAllTracksWithoutEnding(this.state.tracks);\n      this.state.playbackRate = this.state.defaultPlaybackRate;\n      this.state.tracks = [];\n      if (firstTrack)\n        this.state.tracks.push({\n          source: firstTrack\n        });\n    }\n    this.updateUpcomingTracks(...remaining);\n  }\n\n  /**\n   * Update the list of songs that will play after the current song.\n   */\n  public updateUpcomingTracks(...followingSongs: Array<File | Blob | string>) {\n    /* Update the list of tracks without changing the songs at the start of the\n     * list that are unchanged,to avoid uneccesary loading and potential delays.\n     */\n    /**\n     * The iteration variable & partition point.\n     * At the end of the loop, it will be equal to the number of tracks in\n     */\n    let m: number;\n    for (m = 0; m < followingSongs.length && m < this.state.tracks.length - 1; m++) {\n      if (this.state.tracks[m + 1].source !== followingSongs[m])\n        break;\n    }\n    const removed = this.state.tracks.splice(\n      m + 1,\n      this.state.tracks.length - m - 1,\n      ...followingSongs.slice(m).map(source => ({ source }))\n      );\n    playback.stopAllTracksWithoutEnding(removed);\n    scheduling.prepareUpcomingTracks(this.state);\n  }\n\n  /**\n   * Get the list of tracks, including the currently playing track\n   * and all tracks that are queued up to play afterward.\n   */\n  public tracks(): Array<File | Blob | string> {\n    return this.state.tracks.map(t => t.source);\n  }\n\n  /**\n   * Get the download and decode status of every track that is to be played,\n   * including the current one.\n   */\n  public trackStates() {\n    return this.state.tracks.map<TrackState>(track => {\n      const src = track.source;\n      if (!track.data) {\n        if (track.timeouts?.downloadScheduledAt) {\n          return {\n            src,\n            state: 'download-scheduled',\n            downloadingAt: track.timeouts.downloadScheduledAt\n          };\n        } else {\n          return { src, state: 'none' };\n        }\n      } else {\n        if (track.data.state === 'downloaded' &&\n            track.timeouts?.decodeScheduledAt) {\n          return {\n            src,\n            state: 'decoding-scheduled',\n            decodingAt: track.timeouts.decodeScheduledAt\n          };\n        } else if (track.data.state === 'ready') {\n          return {\n            src,\n            state: 'ready',\n            mode: track.data.mode\n          };\n        } else if (track.data.state === 'error') {\n          return {\n            src,\n            state: 'error',\n            error: track.data.error\n          };\n        } else {\n          return {\n            src,\n            state: track.data.state\n          };\n        }\n      }\n    });\n  }\n\n  /**\n   * Configuration options for different thresholds for gapless playback,\n   * this property can't be reassigned, but the properties of the object\n   * it returns can be.\n   *\n   * @readonly\n   */\n  public get thresholds() {\n    return this.state.thresholds;\n  }\n\n  private updateGain() {\n    this.state.gainNode.gain.value =\n      this.state.volume.muted ? 0 : this.state.volume.volume;\n  }\n\n  /**\n   * @returns a double indicating the audio volume,\n   * from 0.0 (silent) to 1.0 (loudest).\n   */\n  public get volume() {\n    return this.state.volume.volume;\n  }\n\n  public set volume(volume: number) {\n    const v = Math.max(0, Math.min(1, volume));\n    if (v !== this.state.volume.volume) {\n      this.state.volume.volume = v;\n      this.updateGain();\n      this.state.sendEvent('volumechange');\n    }\n  }\n\n  /**\n   * @returns A Boolean that determines whether audio is muted.\n   * `true` if the audio is muted and `false` otherwise.\n   */\n  public get muted() {\n    return this.state.volume.muted;\n  }\n\n  public set muted(muted: boolean) {\n    if (muted !== this.state.volume.muted) {\n      this.state.volume.muted = muted;\n      this.updateGain();\n      this.state.sendEvent('volumechange');\n    }\n  }\n\n  /**\n   * @returns the URL of the track to play\n   */\n  public get src(): string {\n    const track = this.state.currentTrack();\n    return typeof track?.source === 'string' && track.source || '';\n  }\n\n  public set src(source: string) {\n    this.updateTracks(source);\n  }\n\n  /**\n   * Begin playback of the audio.\n   */\n  public async play(suppressEvent?: boolean) {\n    if (this.state.context.state === 'suspended')\n      this.state.context.resume();\n    const track = this.state.currentTrack();\n    if (track) {\n      if (track.data?.state === 'ready') {\n        const playState = playback.getPlayState(this.state, track.data);\n        if (playState.state === 'paused') {\n          playback.playCurrentTrackFrom(\n            this.state, playState.positionMillis);\n          if (!suppressEvent)\n            this.state.sendEvent('play');\n        }\n      } else {\n        // Track hasn't loaded yet\n        // Create a promise and callback if neccesary\n        return playback.playTrackWhenLoaded(track);\n      }\n    }\n  }\n\n  /**\n   * Pauses the audio playback.\n   */\n  public pause(suppressEvent?: boolean) {\n    if (this.state.context.state === 'suspended')\n      this.state.context.resume();\n    const track = this.state.currentTrack();\n    if (track?.data?.state === 'ready') {\n      const playState = playback.getPlayState(this.state, track.data);\n      if (playState.state === 'playing') {\n        const nowMillis = this.state.context.currentTime * 1000;\n        const positionMillis =\n          (nowMillis - playState.effectiveStartTimeMillis) *\n          this.state.playbackRate;\n        playback.stopAllTracksWithoutEnding(this.state.tracks, positionMillis);\n        if (!suppressEvent)\n          this.state.sendEvent('pause');\n      }\n    }\n    scheduling.prepareUpcomingTracks(this.state);\n  }\n\n  /**\n   * Skip a certain number of tracks ahead in the queue\n   *\n   * @param count - how many tracks to skip ahead by, default: `1`\n   */\n  public skip(count = 1) {\n    playback.skip(this.state, count);\n  }\n\n  /**\n   * @returns a boolean that indicates whether the audio element is paused.\n   */\n  public get paused() {\n    return this.state.paused();\n  }\n\n  /**\n   * Similar to\n   * {@link @synesthesia-project/precise-audio.PreciseAudio.currentTime},\n   * but returns the time in milliseconds rather than seconds.\n   *\n   * @returns The current playback time in milliseconds\n   */\n  public get currentTimeMillis() {\n    const track = this.state.currentTrack();\n    if (track?.data?.state === 'ready') {\n      const playState = playback.getPlayState(this.state, track.data);\n      if (playState.state === 'paused') {\n        return playState.positionMillis;\n      } else {\n        const nowMillis = this.state.context.currentTime * 1000;\n        return (nowMillis - playState.effectiveStartTimeMillis) *\n          this.state.playbackRate;\n      }\n    }\n    return 0;\n  }\n\n  /**\n   * The current playback time in seconds\n   *\n   * If the media is not yet playing,\n   * the value of `currentTime` indicates the time position within the track\n   * at which playback will begin once the\n   * {@link @synesthesia-project/precise-audio.PreciseAudio.play}\n   * method is called.\n   *\n   * @returns The current playback time in seconds\n   */\n  public get currentTime() {\n    return this.currentTimeMillis / 1000;\n  }\n\n  public set currentTime(positionSeconds: number) {\n    const track = this.state.currentTrack();\n    if (track?.data?.state === 'ready') {\n      const positionMillis = positionSeconds * 1000;\n      const playState = playback.getPlayState(this.state, track.data);\n      if (playState.state === 'paused') {\n        if (track.data.mode === 'basic') {\n          track.data.audio.currentTime = positionMillis / 1000;\n        } else {\n          track.data.playState = {\n            state: 'paused', positionMillis\n          };\n        }\n        this.state.sendEvent('timeupdate');\n      } else {\n        playback.playCurrentTrackFrom(this.state, positionMillis);\n      }\n      this.state.sendEvent('seeked');\n    }\n  }\n\n  /*\n   * Pause playback if neccesary,\n   * make some adjustments to the configuration,\n   * and then resume (if previously playing).\n   *\n   * This should be used when making a change to how you initialize the\n   * web audio pipeline (e.g. changing the pitch).\n   */\n  private changeConfiguration(callback: () => void) {\n    let resume = false;\n    if (!this.paused) {\n      this.pause(true);\n      resume = true;\n    }\n    callback();\n    if (resume) {\n      this.play(true);\n    }\n  }\n\n  public set adjustPitchWithPlaybackRate(adjust: boolean) {\n    this.changeConfiguration(() => {\n      this.state.adjustPitchWithPlaybackRate = adjust;\n    });\n  }\n\n  /**\n   * Should this class attempt to adjust the pitch of the audio when changing\n   * playback rate to compensate.\n   *\n   * This is the usual behaviour for `HTMLAudioElement`\n   *\n   * @default true\n   *\n   */\n  public get adjustPitchWithPlaybackRate() {\n    return this.state.adjustPitchWithPlaybackRate;\n  }\n\n  public set playbackRate(playbackRate: number) {\n    this.changeConfiguration(() => {\n      this.state.playbackRate = playbackRate;\n    });\n    this.state.sendEvent('ratechange');\n  }\n\n  /**\n   * A number indicating the rate at which the media is being played back.\n   * This value is reset to be the same as `defaultPlaybackRate` whenever the\n   * queue of tracks is completely replaced (i.e, when the current track is\n   * changed).\n   *\n   * @returns The number indicating the rate at which the media\n   *          is being played back.\n   */\n  public get playbackRate() {\n    return this.state.playbackRate;\n  }\n\n  public set defaultPlaybackRate(defaultPlaybackRate: number) {\n    this.state.defaultPlaybackRate = defaultPlaybackRate;\n  }\n\n  /**\n   * The value used as the `playbackRate` whenever new music is queued.\n   *\n   * @returns A number indicating the default playback rate\n   */\n  public get defaultPlaybackRate() {\n    return this.state.playbackRate;\n  }\n\n  /**\n   * @returns The length of the currently loaded audio track in seconds\n   */\n  public get duration() {\n    const track = this.state.currentTrack();\n    if (track?.data?.state === 'ready') {\n      if (track.data.mode === 'basic') {\n        return track.data.audio.duration;\n      } else {\n        return track.data.buffer.duration;\n      }\n    }\n    return 0;\n  }\n\n  /**\n   * @returns The length of the currently loaded audio track in milliseconds\n   */\n  public get durationMillis() {\n    return this.duration * 1000;\n  }\n\n  /**\n   * Sets the ID of the audio device to use for output and returns a `Promise`.\n   * This only works when the application is authorized to use\n   * the specified device.\n   *\n   * *Note: this is currently not implemented in PreciseAudio*\n   *\n   * @param sinkId The\n   * [`MediaDeviceInfo.deviceId`](https://developer.mozilla.org/en-US/docs/Web/API/MediaDeviceInfo/deviceId)\n   * of the audio output device.\n   */\n  public async setSinkId(sinkId: string) {\n    console.error('setSinkId() not implemented in PreciseAudio: ' + sinkId);\n  }\n\n  /**\n   * Fired when the user agent can play the media, and estimates that enough\n   * data has been loaded to play the media up to its end without having to stop\n   * for further buffering of content.\n   *\n   * Note: in contrast to `HTMLAudioElement`, `PreciseAudio` will always fire\n   * this event at the same time as `canplaythrough` and `loadeddata`,\n   * as all tracks are always fully preloaded.\n   *\n   * @param listener an [EventListener](https://developer.mozilla.org/en-US/docs/Web/API/EventListener)\n   *                 that expects a {@link @synesthesia-project/precise-audio.PreciseAudioEvent}\n   *                 as a parameter\n   */\n  public addEventListener(event: 'canplay', listener: Listener): void;\n\n  /**\n   * Fired when the user agent can play the media, and estimates that enough\n   * data has been loaded to play the media up to its end without having to stop\n   * for further buffering of content.\n   *\n   * Note: in contrast to `HTMLAudioElement`, `PreciseAudio` will always fire\n   * this event at the same time as `canplay` and `loadeddata`,\n   * as all tracks are always fully preloaded.\n   *\n   * @param listener an [EventListener](https://developer.mozilla.org/en-US/docs/Web/API/EventListener)\n   *                 that expects a {@link @synesthesia-project/precise-audio.PreciseAudioEvent}\n   *                 as a parameter\n   */\n  public addEventListener(event: 'canplaythrough', listener: Listener): void;\n\n  /**\n   * Fired when playback stops when end of the track is reached\n   *\n   * @param listener an [EventListener](https://developer.mozilla.org/en-US/docs/Web/API/EventListener)\n   *                 that expects a {@link @synesthesia-project/precise-audio.PreciseAudioEvent}\n   *                 as a parameter\n   */\n  public addEventListener(event: 'ended', listener: Listener): void;\n\n  /**\n   * Fired when the track could not be loaded due to an error.\n   *\n   * @param listener an [EventListener](https://developer.mozilla.org/en-US/docs/Web/API/EventListener)\n   *                 that expects a {@link @synesthesia-project/precise-audio.PreciseAudioEvent}\n   *                 as a parameter\n   */\n  public addEventListener(event: 'error', listener: ErrorListener): void;\n\n  /**\n   * Fired when the first frame of the media has finished loading.\n   *\n   * Note: in contrast to `HTMLAudioElement`, `PreciseAudio` will always fire\n   * this event at the same time as `canplay` and `canplaythrough`,\n   * as all tracks are always fully preloaded.\n   *\n   * @param listener an [EventListener](https://developer.mozilla.org/en-US/docs/Web/API/EventListener)\n   *                 that expects a {@link @synesthesia-project/precise-audio.PreciseAudioEvent}\n   *                 as a parameter\n   */\n  public addEventListener(event: 'loadeddata', listener: Listener): void;\n\n  /**\n   * Fired when the the next song has started playing (gaplessly).\n   *\n   * @param listener an [EventListener](https://developer.mozilla.org/en-US/docs/Web/API/EventListener)\n   *                 that expects a {@link @synesthesia-project/precise-audio.PreciseAudioEvent}\n   *                 as a parameter\n   */\n  public addEventListener(event: 'next', listener: Listener): void;\n\n  /**\n   * Fired when the audio starts playing\n   *\n   * @param listener an [EventListener](https://developer.mozilla.org/en-US/docs/Web/API/EventListener)\n   *                 that expects a {@link @synesthesia-project/precise-audio.PreciseAudioEvent}\n   *                 as a parameter\n   */\n  public addEventListener(event: 'play', listener: Listener): void;\n\n  /**\n   * Fired when the audio is paused\n   *\n   * (Notably not fired when the audio is stopped\n   * when a new file is being loaded)\n   *\n   * @param listener an [EventListener](https://developer.mozilla.org/en-US/docs/Web/API/EventListener)\n   *                 that expects a {@link @synesthesia-project/precise-audio.PreciseAudioEvent}\n   *                 as a parameter\n   */\n  public addEventListener(event: 'pause', listener: Listener): void;\n\n  /**\n   * Fired when a seek operation completes\n   *\n   * @param listener an [EventListener](https://developer.mozilla.org/en-US/docs/Web/API/EventListener)\n   *                 that expects a {@link @synesthesia-project/precise-audio.PreciseAudioEvent}\n   *                 as a parameter\n   */\n  public addEventListener(event: 'seeked', listener: Listener): void;\n\n  /**\n   * Fired when the time indicated by the currentTime attribute has been updated\n   *\n   * Note: this happens continuously, so instead this class will just call this\n   * at the framerate of the browser using requestAnimationFrame.\n   *\n   * @param listener an [EventListener](https://developer.mozilla.org/en-US/docs/Web/API/EventListener)\n   *                 that expects a {@link @synesthesia-project/precise-audio.PreciseAudioEvent}\n   *                 as a parameter\n   */\n  public addEventListener(event: 'timeupdate', listener: Listener): void;\n\n  /**\n   * Fired when the volume has changed.\n   *\n   * @param listener an [EventListener](https://developer.mozilla.org/en-US/docs/Web/API/EventListener)\n   *                 that expects a {@link @synesthesia-project/precise-audio.PreciseAudioEvent}\n   *                 as a parameter\n   */\n  public addEventListener(event: 'volumechange', listener: Listener): void;\n\n  /**\n   * Fired when the state of any of the enqueued tracks has changed.\n   *\n   * I.E: called whenever the returned value from `trackStatuses()`\n   * will be different.\n   *\n   * @param listener an [EventListener](https://developer.mozilla.org/en-US/docs/Web/API/EventListener)\n   *                 that expects a {@link @synesthesia-project/precise-audio.PreciseAudioEvent}\n   *                 as a parameter\n   */\n  public addEventListener(event: 'trackstateupdate', listener: Listener): void;\n\n  public addEventListener(event: EventTypes, listener: Listener | ErrorListener) {\n    super.addEventListener(event, listener as any);\n  }\n\n  public removeEventListener(event: EventTypes, listener: Listener | ErrorListener) {\n    super.removeEventListener(event, listener as any);\n  }\n\n}\n","var createAudioNode = require('custom-audio-node')\n\nmodule.exports = function PitchShift(audioContext){\n  var instance = new Jungle(audioContext)\n  var input = audioContext.createGain()\n  var wet = audioContext.createGain()\n  var dry = audioContext.createGain()\n  var output = audioContext.createGain()\n\n  dry.gain.value = 0\n\n  input.connect(wet)\n  input.connect(dry)\n\n  wet.connect(instance.input)\n  instance.output.connect(output)\n\n  dry.connect(output)\n\n  var node = createAudioNode(input, output, {\n    dry: {\n      min: 0, \n      defaultValue: 0,\n      target: dry.gain\n    },\n    wet: {\n      min: 0, \n      defaultValue: 1,\n      target: wet.gain\n    }\n  })\n\n  instance.setPitchOffset(getMultiplier(12))\n\n  var transpose = 0\n  Object.defineProperty(node, 'transpose', {\n    set: function(value){\n      transpose = getMultiplier(value)\n      instance.setPitchOffset(transpose)\n    },\n    get: function(){\n      return transpose\n    }\n  })\n  return node\n}\n\nfunction getMultiplier(x){\n\n  // don't ask...\n  if (x<0){\n    return x/12\n  } else {\n    var a5 = 1.8149080040913423e-7\n    var a4 = -0.000019413043101157434\n    var a3 = 0.0009795096626987743\n    var a2 = -0.014147877819596033\n    var a1 = 0.23005591195033048\n    var a0 = 0.02278153473118749\n\n    var x1 = x\n    var x2 = x*x\n    var x3 = x*x*x\n    var x4 = x*x*x*x\n    var x5 = x*x*x*x*x\n\n    return a0 + x1*a1 + x2*a2 + x3*a3 + x4*a4 + x5*a5\n  }\n\n}\n\n// include https://github.com/cwilso/Audio-Input-Effects/blob/master/js/jungle.js\n\n// Copyright 2012, Google Inc.\n// All rights reserved.\n// \n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n// \n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n// \n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nfunction createFadeBuffer(context, activeTime, fadeTime) {\n    var length1 = activeTime * context.sampleRate;\n    var length2 = (activeTime - 2*fadeTime) * context.sampleRate;\n    var length = length1 + length2;\n    var buffer = context.createBuffer(1, length, context.sampleRate);\n    var p = buffer.getChannelData(0);\n        \n    var fadeLength = fadeTime * context.sampleRate;\n\n    var fadeIndex1 = fadeLength;\n    var fadeIndex2 = length1 - fadeLength;\n    \n    // 1st part of cycle\n    for (var i = 0; i < length1; ++i) {\n        var value;\n        \n        if (i < fadeIndex1) {\n            value = Math.sqrt(i / fadeLength);\n        } else if (i >= fadeIndex2) {\n            value = Math.sqrt(1 - (i - fadeIndex2) / fadeLength);\n        } else {\n            value = 1;\n        }\n        \n        p[i] = value;\n    }\n\n    // 2nd part\n    for (var i = length1; i < length; ++i) {\n        p[i] = 0;\n    }\n    \n    \n    return buffer;\n}\n\nfunction createDelayTimeBuffer(context, activeTime, fadeTime, shiftUp) {\n    var length1 = activeTime * context.sampleRate;\n    var length2 = (activeTime - 2*fadeTime) * context.sampleRate;\n    var length = length1 + length2;\n    var buffer = context.createBuffer(1, length, context.sampleRate);\n    var p = buffer.getChannelData(0);\n    \n    // 1st part of cycle\n    for (var i = 0; i < length1; ++i) {\n        if (shiftUp)\n          // This line does shift-up transpose\n          p[i] = (length1-i)/length;\n        else\n          // This line does shift-down transpose\n          p[i] = i / length1;\n    }\n\n    // 2nd part\n    for (var i = length1; i < length; ++i) {\n        p[i] = 0;\n    }\n\n    return buffer;\n}\n\nvar delayTime = 0.100;\nvar fadeTime = 0.050;\nvar bufferTime = 0.100;\n\nfunction Jungle(context) {\n    this.context = context;\n    // Create nodes for the input and output of this \"module\".\n    var input = context.createGain();\n    var output = context.createGain();\n    this.input = input;\n    this.output = output;\n    \n    // Delay modulation.\n    var mod1 = context.createBufferSource();\n    var mod2 = context.createBufferSource();\n    var mod3 = context.createBufferSource();\n    var mod4 = context.createBufferSource();\n    this.shiftDownBuffer = createDelayTimeBuffer(context, bufferTime, fadeTime, false);\n    this.shiftUpBuffer = createDelayTimeBuffer(context, bufferTime, fadeTime, true);\n    mod1.buffer = this.shiftDownBuffer;\n    mod2.buffer = this.shiftDownBuffer;\n    mod3.buffer = this.shiftUpBuffer;\n    mod4.buffer = this.shiftUpBuffer;\n    mod1.loop = true;\n    mod2.loop = true;\n    mod3.loop = true;\n    mod4.loop = true;\n\n    // for switching between oct-up and oct-down\n    var mod1Gain = context.createGain();\n    var mod2Gain = context.createGain();\n    var mod3Gain = context.createGain();\n    mod3Gain.gain.value = 0;\n    var mod4Gain = context.createGain();\n    mod4Gain.gain.value = 0;\n\n    mod1.connect(mod1Gain);\n    mod2.connect(mod2Gain);\n    mod3.connect(mod3Gain);\n    mod4.connect(mod4Gain);\n\n    // Delay amount for changing pitch.\n    var modGain1 = context.createGain();\n    var modGain2 = context.createGain();\n\n    var delay1 = context.createDelay();\n    var delay2 = context.createDelay();\n    mod1Gain.connect(modGain1);\n    mod2Gain.connect(modGain2);\n    mod3Gain.connect(modGain1);\n    mod4Gain.connect(modGain2);\n    modGain1.connect(delay1.delayTime);\n    modGain2.connect(delay2.delayTime);\n\n    // Crossfading.\n    var fade1 = context.createBufferSource();\n    var fade2 = context.createBufferSource();\n    var fadeBuffer = createFadeBuffer(context, bufferTime, fadeTime);\n    fade1.buffer = fadeBuffer\n    fade2.buffer = fadeBuffer;\n    fade1.loop = true;\n    fade2.loop = true;\n\n    var mix1 = context.createGain();\n    var mix2 = context.createGain();\n    mix1.gain.value = 0;\n    mix2.gain.value = 0;\n\n    fade1.connect(mix1.gain);    \n    fade2.connect(mix2.gain);\n        \n    // Connect processing graph.\n    input.connect(delay1);\n    input.connect(delay2);    \n    delay1.connect(mix1);\n    delay2.connect(mix2);\n    mix1.connect(output);\n    mix2.connect(output);\n    \n    // Start\n    var t = context.currentTime + 0.050;\n    var t2 = t + bufferTime - fadeTime;\n    mod1.start(t);\n    mod2.start(t2);\n    mod3.start(t);\n    mod4.start(t2);\n    fade1.start(t);\n    fade2.start(t2);\n\n    this.mod1 = mod1;\n    this.mod2 = mod2;\n    this.mod1Gain = mod1Gain;\n    this.mod2Gain = mod2Gain;\n    this.mod3Gain = mod3Gain;\n    this.mod4Gain = mod4Gain;\n    this.modGain1 = modGain1;\n    this.modGain2 = modGain2;\n    this.fade1 = fade1;\n    this.fade2 = fade2;\n    this.mix1 = mix1;\n    this.mix2 = mix2;\n    this.delay1 = delay1;\n    this.delay2 = delay2;\n    \n    this.setDelay(delayTime);\n}\n\nJungle.prototype.setDelay = function(delayTime) {\n    this.modGain1.gain.setTargetAtTime(0.5*delayTime, 0, 0.010);\n    this.modGain2.gain.setTargetAtTime(0.5*delayTime, 0, 0.010);\n}\n\nJungle.prototype.setPitchOffset = function(mult) {\n  if (mult>0) { // pitch up\n    this.mod1Gain.gain.value = 0;\n    this.mod2Gain.gain.value = 0;\n    this.mod3Gain.gain.value = 1;\n    this.mod4Gain.gain.value = 1;\n  } else { // pitch down\n    this.mod1Gain.gain.value = 1;\n    this.mod2Gain.gain.value = 1;\n    this.mod3Gain.gain.value = 0;\n    this.mod4Gain.gain.value = 0;\n  }\n  this.setDelay(delayTime*Math.abs(mult));\n}","var createAudioParam = require('./audio-param')\n\nmodule.exports = function(input, output, params, onDestinationChange){\n  var audioContext = (input || output).context\n\n  var node = audioContext.createGain()\n  node._onDestinationChange = onDestinationChange\n\n  if (input){\n    node.connect(input)\n  }\n\n  node._output = output\n  node._targetCount = 0\n\n  if (output){\n    node.connect = connect\n    node.disconnect = disconnect\n  }\n\n  addAudioParams(node, params)\n\n  return node\n}\n\nmodule.exports.createAudioParam = createAudioParam\n\nfunction connect(destination, channel){\n  this._targetCount += 1\n  this._output.connect(destination, channel)\n  if (typeof this._onDestinationChange === 'function'){\n    this._onDestinationChange(this._targetCount)\n  }\n}\n\nfunction disconnect(param){\n  this._targetCount = 0\n  this._output.disconnect(param)\n  if (typeof this._onDestinationChange === 'function'){\n    this._onDestinationChange(this._targetCount)\n  }\n}\n\nfunction addAudioParams(node, params){\n  if (params){\n    var keys = Object.keys(params)\n    for (var i=0,l=keys.length;i<l;i++){\n      var key = keys[i]\n      node[key] = createAudioParam(node.context, key, params[key])\n    }\n  }\n}","module.exports = function(audioContext, name, options){\n  // options: provider, target(s)\n\n  options = options || {}\n\n  var targets = options.targets\n\n  if (!targets && options.target){\n    targets = [options.target]\n  } else if (!targets){\n    targets = []\n  }\n\n  var param = Object.create(AudioParam.prototype, {\n    value: {\n      get: function(){\n        return param._lastValue\n      },\n      set: function(value){\n        value = param.fence(value)\n        param._lastValue = value\n        for (var i=0,l=targets.length;i<l;i++){\n          var target = targets[i]\n          target.value = value\n        }\n      }\n    },\n    defaultValue: {\n      get: function(){\n        return options.defaultValue\n      }\n    },\n    name: {\n      value: name,\n      writable: false\n    },\n    min: {\n      value: options.min,\n      writable: false\n    },\n    max: {\n      value: options.max,\n      writable: false\n    }\n  })\n\n\n\n  param._targets = targets\n  param._lastValue = options.defaultValue\n\n  // override proto-methods\n  param.setValueAtTime = setValueAtTime\n  param.linearRampToValueAtTime = linearRampToValueAtTime\n  param.exponentialRampToValueAtTime = exponentialRampToValueAtTime\n  param.setTargetAtTime = setTargetAtTime\n  param.setValueCurveAtTime = setValueCurveAtTime\n  param.cancelScheduledValues = cancelScheduledValues\n  param.addTarget = addTarget\n  param.clearTargets = clearTargets\n  param.context = audioContext\n\n  // get value between min and max\n  param.fence = fence\n  \n  // set initial value\n  if (options.defaultValue != null){\n    param.value = options.defaultValue\n  }\n\n  return param\n}\n\nfunction fence(value){\n  if (this.min != null){\n    value = Math.max(this.min, value)\n  }\n\n  if (this.max != null){\n    value = Math.min(this.max, value)\n\n  }\n  return value\n}\n\nfunction setValueAtTime(value, startTime){\n  var targets = this._targets\n  value = this.fence(value)\n\n  this._lastValue = value\n\n  for (var i=0,l=targets.length;i<l;i++){\n    targets[i].setValueAtTime(value, startTime)\n  }\n}\n\nfunction setTargetAtTime(value, startTime, timeConstant){\n  // this needs to be rewritten to use custom curve\n  var targets = this._targets\n  value = this.fence(value)\n  for (var i=0,l=targets.length;i<l;i++){\n    if (targets[i].setTargetAtTime){\n      targets[i].setTargetAtTime(value, startTime, timeConstant)\n    }\n  }\n}\n\nfunction linearRampToValueAtTime(value, endTime){\n  var targets = this._targets\n  value = this.fence(value)\n\n  this._lastValue = value\n\n  for (var i=0,l=targets.length;i<l;i++){\n    targets[i].linearRampToValueAtTime(value, endTime)\n  }\n}\n\nfunction exponentialRampToValueAtTime(value, endTime){\n  var targets = this._targets\n  value = this.fence(value)\n\n  this._lastValue = value\n\n  for (var i=0,l=targets.length;i<l;i++){\n    targets[i].exponentialRampToValueAtTime(value, endTime)\n  }\n}\n\nfunction setValueCurveAtTime(curve, startTime, duration){\n  var targets = this._targets\n  this._lastValue = curve[curve.length-1]\n\n  for (var i=0,l=targets.length;i<l;i++){\n    targets[i].setValueCurveAtTime(curve, startTime, duration)\n  }\n}\n\nfunction cancelScheduledValues(startTime){\n  var targets = this._targets\n  for (var i=0,l=targets.length;i<l;i++){\n    targets[i].cancelScheduledValues(startTime)\n  }\n}\n\nfunction clearTargets(){\n  this._targets = []\n}\n\nfunction addTarget(target){\n  this._targets.push(target)\n  if (this._lastValue != null){\n    target.value = this._lastValue\n  }\n}","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst MPEGAudioVersionMapping = {\n    0: '2.5',\n    2: '2',\n    3: '1'\n};\nconst MPEGLayerMapping = {\n    1: '3',\n    2: '2',\n    3: '1'\n};\nconst MODES = ['stereo', 'joint_stereo', 'dual_channel', 'mono'];\nconst SAMPLE_RATES = {\n    '1': [44100, 48000, 32000],\n    '2': [22050, 24000, 16000],\n    '2.5': [11025, 12000, 8000]\n};\nconst BITRATES_RAW = {\n    'MPEG-1-Layer-1': [0, 32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448],\n    'MPEG-1-Layer-2': [0, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384],\n    'MPEG-1-Layer-3': [0, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320],\n    'MPEG-2-Layer-1': [0, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256],\n    'MPEG-2-Layer-O': [0, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160],\n};\nconst BITRATES = {\n    '1': {\n        '1': BITRATES_RAW['MPEG-1-Layer-1'],\n        '2': BITRATES_RAW['MPEG-1-Layer-2'],\n        '3': BITRATES_RAW['MPEG-1-Layer-3']\n    },\n    '2': {\n        '1': BITRATES_RAW['MPEG-2-Layer-1'],\n        '2': BITRATES_RAW['MPEG-2-Layer-O'],\n        '3': BITRATES_RAW['MPEG-2-Layer-O']\n    },\n    '2.5': {\n        '1': BITRATES_RAW['MPEG-2-Layer-1'],\n        '2': BITRATES_RAW['MPEG-2-Layer-O'],\n        '3': BITRATES_RAW['MPEG-2-Layer-O']\n    }\n};\nconst SAMPLES_PER_FRAME = {\n    '1': {\n        '1': 384,\n        '2': 1152,\n        '3': 1152\n    },\n    '2': {\n        '1': 384,\n        '2': 1152,\n        '3': 576\n    },\n    '2.5': {\n        '1': 384,\n        '2': 1152,\n        '3': 576\n    }\n};\nconst LAYER_3_SIDE_INFORMATION_BYTES = {\n    '1': {\n        'dual': 32,\n        'mono': 17\n    },\n    '2': {\n        'dual': 17,\n        'mono': 9\n    },\n    '2.5': {\n        'dual': 17,\n        'mono': 9\n    }\n};\nfunction extractAsciiString(bytes, index, length) {\n    let str = '';\n    for (let i = 0; i < length; i++) {\n        const char = bytes[index + i];\n        if (char > 31 && char < 127)\n            str += String.fromCharCode(char);\n    }\n    return str;\n}\nfunction parseAudioFrameHeader(bytes, offset) {\n    const frameHeader = [\n        bytes[offset],\n        bytes[offset + 1],\n        bytes[offset + 2],\n        bytes[offset + 3]\n    ];\n    const frameSync = (frameHeader[0] << 3) | (frameHeader[1] >> 5);\n    const audioVersion = (frameHeader[1] >> 3) & 0x3;\n    const layerIndex = (frameHeader[1] >> 1) & 0x3;\n    const bitrateIndex = frameHeader[2] >> 4;\n    const sampleRateIndex = (frameHeader[2] >> 2) & 0x3;\n    const mode = MODES[(frameHeader[3] >> 6) & 0x3];\n    if (frameSync !== 0x7ff)\n        return null;\n    if (audioVersion === 0x1)\n        return null;\n    if (layerIndex === 0x0)\n        return null;\n    if (bitrateIndex === 0xf)\n        return null;\n    if (sampleRateIndex === 0x3)\n        return null;\n    const version = MPEGAudioVersionMapping[audioVersion];\n    const layer = MPEGLayerMapping[layerIndex];\n    const bitrate = BITRATES[version][layer][bitrateIndex];\n    const sampleRate = SAMPLE_RATES[version][sampleRateIndex];\n    const samplesPerFrame = SAMPLES_PER_FRAME[version][layer];\n    const metadata = {\n        version,\n        layer,\n        bitrate,\n        sampleRate,\n        samplesPerFrame,\n        mode\n    };\n    let dataStart = null;\n    if (layer === '3') {\n        const sideMode = mode === 'mono' ? mode : 'dual';\n        const sideInformationBytes = LAYER_3_SIDE_INFORMATION_BYTES[version][sideMode];\n        dataStart =\n            4 +\n                sideInformationBytes;\n    }\n    else {\n        console.log('Unable to calculate start of data frame (TODO)');\n    }\n    if (dataStart !== null) {\n        const vbrStart = offset + dataStart;\n        const vbrHeaderID = extractAsciiString(bytes, vbrStart, 4);\n        if (vbrHeaderID === 'Xing' || vbrHeaderID === 'Info') {\n            const hasFrames = (bytes[vbrStart + 7] & 0x1) === 0x1;\n            const hasBytes = (bytes[vbrStart + 7] & 0x2) === 0x2;\n            const hasTOC = (bytes[vbrStart + 7] & 0x4) === 0x4;\n            const hasQuality = (bytes[vbrStart + 7] & 0x8) === 0x8;\n            let numberOfFrames;\n            const framesStart = vbrStart + 8;\n            if (hasFrames) {\n                numberOfFrames =\n                    (bytes[framesStart] << 24) +\n                        (bytes[framesStart + 1] << 16) +\n                        (bytes[framesStart + 2] << 8) +\n                        bytes[framesStart + 3];\n            }\n            metadata.vbrInfo = {\n                isCBR: vbrHeaderID === 'Info',\n                numberOfFrames\n            };\n            const lameExtensionStart = vbrStart + 8 +\n                (hasFrames ? 4 : 0) +\n                (hasBytes ? 4 : 0) +\n                (hasTOC ? 100 : 0) +\n                (hasQuality ? 4 : 0);\n            const encoder = extractAsciiString(bytes, lameExtensionStart, 9);\n            if (encoder.length === 9) {\n                const paddingStart = (bytes[lameExtensionStart + 21] << 4) |\n                    (bytes[lameExtensionStart + 22] >> 4);\n                const paddingEnd = ((bytes[lameExtensionStart + 22] & 0xf) << 8) |\n                    bytes[lameExtensionStart + 23];\n                metadata.lameInfo = {\n                    encoder,\n                    paddingStart,\n                    paddingEnd\n                };\n            }\n        }\n    }\n    return metadata;\n}\nfunction extractTagSize(bytes, offset) {\n    if (extractAsciiString(bytes, offset, 3) === 'ID3') {\n        const flags = bytes[offset + 5];\n        const hasFooter = (flags & 0x10) === 0x10;\n        const size = ((bytes[offset + 6] << 21) |\n            (bytes[offset + 7] << 14) |\n            (bytes[offset + 8] << 7) |\n            (bytes[offset + 9]));\n        return 10 + size + (hasFooter ? 10 : 0);\n    }\n    return 0;\n}\nfunction getMetadata(buffer) {\n    const bytes = new Uint8Array(buffer);\n    let offset = 0;\n    let tagSize = 0;\n    while ((tagSize = extractTagSize(bytes, offset)) !== 0)\n        offset += tagSize;\n    console.log('offset:', offset);\n    return parseAudioFrameHeader(bytes, offset);\n}\nexports.getMetadata = getMetadata;\nexports.default = getMetadata;\n","import { Track } from './data';\nimport { EventTypes } from './events';\nimport { Thresholds } from './tresholds';\nimport { getPlayState } from './playback';\n\nfunction strictArrayGet<T>(arr: T[], i: number): T | undefined {\n  return arr[i];\n}\n\nexport class State {\n  public readonly context: AudioContext;\n  public readonly gainNode: GainNode;\n  public animationFrameRequest: null | number = null;\n  /**\n   * Playback rate for the current queue of tracks\n   */\n  public playbackRate = 1;\n  public defaultPlaybackRate = 1;\n  public adjustPitchWithPlaybackRate = true;\n  public readonly volume = {\n    volume: 1,\n    muted: false\n  };\n  public tracks: Track[] = [];\n  public readonly thresholds = new Thresholds();\n  /**\n   * Dispatch the given event to listeners\n   */\n  public readonly sendEvent: (event: EventTypes) => void;\n  public readonly dispatchError: (error: Error) => void;\n\n  public constructor(\n      sendEvent: (event: EventTypes) => void,\n      dispatchError: (error: Error) => void) {\n    this.context = new AudioContext();\n    this.gainNode = this.context.createGain();\n    this.gainNode.connect(this.context.destination);\n    this.sendEvent = sendEvent;\n    this.dispatchError = dispatchError;\n  }\n\n  public currentTrack() {\n    return strictArrayGet(this.tracks, 0);\n  }\n\n  public paused() {\n    const track = this.currentTrack();\n    return track?.data?.state !== 'ready' ||\n      getPlayState(this, track.data).state === 'paused';\n  }\n}\n","\ntype BasicModeThreshold = 'never' | 'always' | number;\n\nexport class Thresholds {\n\n  private _basicModeThresholdSeconds: BasicModeThreshold = 'never';\n\n  public get basicModeThresholdSeconds() {\n    return this._basicModeThresholdSeconds;\n  }\n\n  /**\n   * How many seconds long does a song need to be for it not to be loaded in\n   * `\"basic\"` mode instead of `\"full\"` mode.\n   *\n   * The normal mode of operation for `PreciseAudio` is to load and decode every\n   * track in `full`, and keep it in memory while playing / paused. This is what\n   * allows for accurate seeking, and for gapless playback.\n   *\n   * However, audio files can be very long, and for some files (e.g. files that\n   * may be multiple hours long),\n   * loading the entire track into memory is either infeasible,\n   * or extremely inefficient.\n   *\n   * Rather than require you to use something other than `PreciseAudio` for\n   * playing these tracks,\n   * this property allows you to specify a threshold duration,\n   * where any tracks longer than this duration will be played using a\n   * [`HTMLAudioElement`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLAudioElement)\n   * instead.\n   * This will effectively disable gapless playback,\n   * and decrease the timing precision for these tracks,\n   * however it does allow you to enqueue long tracks alongside shorter ones\n   * that fall within this threshold.\n   *\n   * One of:\n   *\n   * * `\"never\"` - *(default)* Never use `basic` mode,\n   *   always load and decode every track in `full`, regardless of duration.\n   * * `\"always\"` - Always use `basic` mode, this will effectively disable\n   *   gapless playback and decrease the timing precision for all tracks.\n   * * a `number` - Detailing the minimum number of seconds long a track needs\n   *   to be before it is loaded using `basic` mode.\n   *\n   * @param threshold The new value for `basicModeThresholdSeconds`\n   */\n  public set basicModeThresholdSeconds(threshold: BasicModeThreshold) {\n    if (threshold === 'always' || threshold === 'never') {\n      this._basicModeThresholdSeconds = threshold;\n    } else if (typeof threshold === 'number') {\n      this._basicModeThresholdSeconds = threshold <= 0 ? 'never' : threshold;\n    } else {\n      throw new Error(`Invalid value for basicModeThresholdSeconds: ${threshold}`);\n    }\n  }\n  private _downloadThresholdSeconds: number = 10;\n\n  public get downloadThresholdSeconds() {\n    return this._downloadThresholdSeconds;\n  }\n\n  /**\n   * How long before the current song ends will we start to\n   * download the next track, and load it into RAM.\n   *\n   * More precisely, at what point before we run out of ready audio do we start\n   * to download the next track. More than one track may need to be downloaded\n   * and queued when the length of a track is less than this threshold.\n   */\n  public set downloadThresholdSeconds(threshold: number) {\n    if (typeof threshold === 'number') {\n      this._downloadThresholdSeconds = Math.max(0, threshold);\n    } else {\n      throw new Error(`Invalid value for downloadThresholdSeconds: ${threshold}`);\n    }\n  }\n\n  private _decodeThresholdSeconds: number = 2;\n  public get decodeThresholdSeconds() {\n    return this._decodeThresholdSeconds;\n  }\n\n  /**\n   * How long before the current song ends will we start to\n   * decode (uncompress) the next track into PCM.\n   *\n   * This is usually a pretty quick process, but can take some time for longer\n   * tracks. It's good to hold off doing this until later to save on RAM usage.\n   */\n  public set decodeThresholdSeconds(threshold: number) {\n    if (typeof threshold === 'number') {\n      this._decodeThresholdSeconds = Math.max(0, threshold);\n    } else {\n      throw new Error(`Invalid value for decodeThresholdSeconds: ${threshold}`);\n    }\n  }\n}\n"],"sourceRoot":""}